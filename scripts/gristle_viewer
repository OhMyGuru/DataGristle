#!/usr/bin/env python
""" Displays a single record of a file, one field per line, with field names
    displayed as labels to the left of the field values.  Also allows simple
    navigation between records.

    usage: View one record at a time from a csv formatted with headers

        [-h] [-i [INFILES [INFILES ...]]] [-o OUTFILE] [-d DELIMITER]
        [-q {quote_all,quote_minimal,quote_nonnumeric,quote_none}]
        [--quotechar QUOTECHAR] [--escapechar ESCAPECHAR] [--has-header]
        [-r RECNUM] [-V] [--long-help]

    optional arguments:
    -h, --help            show this help message and exit
    -i [INFILES [INFILES ...]], --infiles [INFILES [INFILES ...]]
                            input filenames or default to for stdin
    -o OUTFILE, --outfile OUTFILE
                            output filename or '-' for stdout (the default)
    -d DELIMITER, --delimiter DELIMITER
                            csv delimiter
    -q {quote_all,quote_minimal,quote_nonnumeric,quote_none}, --quoting {quote_all,quote_minimal,quote_nonnumeric,quote_none}
                            csv quoting
    --quotechar QUOTECHAR
                            csv quotechar
    --escapechar ESCAPECHAR
                            csv escapechar
    --has-header          csv dialect - indicates header exists
    -r RECNUM, --recnum RECNUM
                            Displays this record number based on 0 offset,
                            defaulting to 1
    -V, --version         show version number then exit
    --long-help           Print more verbose help

    Examples:
       $ gristle_viewer sample.csv -r 3
                    Presents the third record in the file with one field per line
                    and field names from the header record as labels in the left
                    column.
       $ gristle_viewer sample.csv -r 3  -d '|' -q quote_none
                    In addition to what was described in the first example this
                    adds explicit csv dialect overrides.

    This source code is protected by the BSD license.  See the file "LICENSE"
    in the source code root directory for the full language or refer to it here:
       http://opensource.org/licenses/BSD-3-Clause
    Copyright 2011,2012,2013,2017 Ken Farmer
"""
#    To do:
#       1.  check for recnum > number of records in input file
#       2.  consider adding records up to some threshold to dictionary
#           to speed navigation for files.
#       3.  confirm that record counting works identical for each situation
#       5.  improve error if no args provided - recommend -h for help

import sys
import csv
import fileinput
from os.path import basename
from pprint import pprint as pp
from typing import Dict, List, Optional, Any, Tuple
from signal import signal, SIGPIPE, SIG_DFL

import datagristle.file_type as file_type
import datagristle.field_determinator  as field_determinator
import datagristle.field_type as field_type
import datagristle.configulator as configulator
import datagristle.csvhelper as csvhelper

#Ignore SIG_PIPE and don't throw exceptions on it... (http://docs.python.org/library/signal.html)
signal(SIGPIPE, SIG_DFL)

NAME = basename(__file__)
SHORT_HELP = 'View one record at a time from a csv formatted with headers\n'


def main():
    """ Analyzes file then displays a single record and allows simple
        navigation between records.
    """
    config = get_args()
    try:
        dialect, field_names = get_input_file_info(config['infiles'],
                                                   config['delimiter'],
                                                   config['quoting'],
                                                   config['quotechar'],
                                                   config['has_header'])
    except file_type.IOErrorEmptyFile:
        print('ERROR: empty file')
        sys.exit(0)

    while True:
        rec = get_rec(config['infiles'],
                      config['recnum'],
                      dialect)
        if rec is None:
            print('No record found')
            return

        display_rec(rec, field_names, config['outfile'])

        # Need to end here if data is being directed to a file - and not interactive
        if config['outfile'] != '-':
            break

        response = input('Rec: %d     Q[uit] P[rev] N[ext] T[op], or a specific record number: ' % config['recnum']).lower()
        if response == 'q':
            break
        elif response == 'p':
            config['recnum'] -= 1
        elif response == 'n':
            config['recnum'] += 1
        elif response == 't':
            config['recnum'] = 0
        elif field_type._get_type(response) == 'integer':
            config['recnum'] = int(response)
        else:
            print('Invalid response, please enter q, p, n, t, or a specific record number')



def get_input_file_info(input_files: List[str],
                        delimiter: str,
                        quoting: str,
                        quotechar: str,
                        has_header: bool) -> Tuple[csvhelper.Dialect, List[str]]:
    """ Gets information about csv dialect and field info from input files
        and user-supplied options.

        Supports manual csv dialect creation - which is necessary
        if the automatic dialect detects gets confused about a file format.
        Manual csv dialect creation is triggered by the existance of
        a delimiter in opts.

        Otherwise, it will attempt to use the automatic dialect
        detection - which only works for files passed in as args,
        which show up here as the input arg files.

        Returns:
            - dialect
            - field_names
        Raises:
            - file_type.IOErrorEmptyFile
    """
    assert input_files

    my_file = file_type.FileTyper(input_files[0],
                                  delimiter=delimiter,
                                  quoting=quoting)

    if delimiter:
        dialect = csvhelper.Dialect(delimiter=delimiter,
                                    has_header=has_header,
                                    quoting=file_type.get_quote_number(quoting),
                                    quotechar=quotechar,
                                    lineterminator='\n')
        my_file.analyze_file()
    else:
        dialect = my_file.analyze_file()

    my_fields = field_determinator.FieldDeterminator(input_files[0],
                                                     my_file.format_type,
                                                     my_file.field_cnt,
                                                     dialect.has_header,
                                                     dialect)
    my_fields.analyze_fields()

    return dialect, my_fields.field_names



def display_rec(rec: str,
                field_names: List[str],
                outfile_name: str) -> None:
    """ Displays a single record
    """
    # figure out label length for formatting:
    if field_names:
        max_v_len = 0
        for val in field_names.values():
            if len(val) > max_v_len:
                max_v_len = len(val)
        min_format_len = max_v_len + 4
    else:
        for f_sub in range(len(rec)):
            field_names.append('field_%d' % f_sub)
        min_format_len = 12

    if outfile_name != '-':
        outfile = open(outfile_name, 'w')
    else:
        outfile = sys.stdout

    # write in column order:
    for f_sub in range(len(rec)):
        try:
            outfile.write('%-*s  -  %-40s\n' % (min_format_len, field_names[f_sub], rec[f_sub]))
        except KeyError:
            outfile.write('*** Missing Field - possibly due to csv parsing issues ***\n')

    if outfile_name != '-':
        outfile.close()



def get_rec(files: List[str], recnum: int, dialect: csv.Dialect) -> Optional[List[Any]]:
    """ Gets a single record from a file
        Since it reads from the begining of the file it can take a while to get
        to records at the end of a large file

        To do:
           - possibly keep file open in case user wants to navigate about
           - possibly keep some of the data in a dictionary in case the user
             wants to navigate about
    """
    found = None
    for row in csv.reader(fileinput.input(files), dialect):
        if fileinput.lineno() == recnum+1:
            found = row
            break
    fileinput.close()
    return found


class ViewerConfigulator(configulator.Config):
    def validate_custom_config(self, config: configulator.CONFIG_TYPE):
        if config['infiles'] == '-':
            self.parser.error('An input filename is required')


def get_args() -> Dict[str, Any]:
    config_mgr = ViewerConfigulator(NAME, SHORT_HELP, __doc__)
    config_mgr.add_standard_config('infiles')
    config_mgr.add_standard_config('outfile')
    config_mgr.add_standard_config('delimiter')
    config_mgr.add_standard_config('quoting')
    config_mgr.add_standard_config('quotechar')
    config_mgr.add_standard_config('escapechar')
    config_mgr.add_standard_config('has_header')
    config_mgr.add_custom_config(name='recnum',
                                 short_name='r',
                                 arg_type='option',
                                 default=0,
                                 config_type=int,
                                 help_msg='Displays this record number based on 0 offset, defaulting to 1')
    config_mgr.process_configs()
    return config_mgr.config



if __name__ == '__main__':
    sys.exit(main())
