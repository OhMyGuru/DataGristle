#!/usr/bin/env python
"""
Compares two files and writes rows to five output files:
    <new file name>.insert
    <new file name>.delete
    <new file name>.chgnew
    <new file name>.chgold
    <new file name>.same


Usage: gristle_differ used to compare two files based on a key in column 0,
and comparing only columns 1 & 2, and writing the verbose results to stdout:
   $ gristle_differ -1 file_one.dat -2 file_two.dat -k 0 -c 1,2,3,4,5 -v

     In file1 only:           5
     In file1 only:           7
     In file2 only:           45
     In both but different:   44
     file1 data: Barack Obamahttp://en.wikipedia.org/wiki/Barack_Obama20/01/2009IncumbentIllinois
     file2 data: Barack Obamahttp://en.wikipedia.org/wiki/Barack_Obama20/01/200920/01/2017Illinois

     Counts:
        File1 records:        45
        File2 records:        43
        In file1 only:        3
        In file2 only:        1
        Same:                 40
        Changed:              1

Note that in the above example, the Counts section w, and 'file1 data'
and 'file2 data' were only printed due to the verbose option.


Options:
  -h, --help            Show this help message and exit.
  --long-help           Print more verbose help.
  -v, --verbose         Prints far more details on comparisons and stats.
                        The default is False (off).
  -1 FILE1, --file1=FILE1
                        First file to compare.
  -2 FILE2, --file2=FILE2
                        Second file to compare.
  -k KEYCOL, --keycol=KEYCOL
                        Specify the columns that constitute a unique row with
                        a comma-delimited list of numbers using a 0-offset.
                        This is a required option.
  -c COMPARECOL, --comparecol=COMPARECOL
                        Specify the columns to be compared with a comma-
                        delimited listof numbers using a 0-offset.  This is a
                        required option.
  -d DELIMITER, --delimiter=DELIMITER
                        Specify a quoted field delimiter.  If you don't provide
                        this, gristle_differ will attempt to determine it.
  -s, --sorted          Large files must be sorted by key - TBD
  --hasheader           indicates that there is a header in the file.
  --recdelimiter=RECDELIMITER
  --maxsize=MAXSIZE     can override max number of rows to collect.  Defaul is
                        10000 rows.

This source code is protected by the BSD license.  See the file "LICENSE"
in the source code root directory for the full language or refer to it here:
    http://opensource.org/licenses/BSD-3-Clause
Copyright 2011,2012,2013,2014 Ken Farmer

"""
#--- standard modules ------------------
from __future__ import division
import sys
import os
import argparse
import csv
import logging
from  os.path import isfile, isdir, exists
from  os.path import dirname, basename
from  os.path import join as pjoin
from  pprint  import pprint as pp

import appdirs
import cletus.cletus_config as conf

#--- gristle modules -------------------
# lets get pathing set for running code out of project structure & testing it via tox
sys.path.append('../')
sys.path.append('../../')
sys.path.insert(0, dirname(dirname(os.path.abspath(__file__))))

import gristle.common       as comm
from   gristle.common  import abort, isnumeric
from gristle.csvhelper import create_dialect
import gristle.file_delta   as gdelta
import gristle.file_sorter  as gsorter
import gristle.file_deduper as gdeduper

#Ignore SIG_PIPE and don't throw exceptions on it... 
#(http://docs.python.org/library/signal.html)
from signal import signal, SIGPIPE, SIG_DFL
signal(SIGPIPE,SIG_DFL)

logging.basicConfig()

def main():
    """ runs all processes:
            - gets args
            - compares files
            - writes counts
    """

    # collect any config file items then override them with args and assemble the
    # consolidated info in the 'config' var:
    desc = ("gristle_differ is used to compare two files and writes the differences to "
            "five output files named after the inputs with the suffixes: "
            ".insert, .delete, .same, .chgold, .chgnew.  The program sorts the "
            "two files based on unique key columns, can ignore certain columns "
            "for the comparison, and then can perform some simple transformations."
            "\n"
            "   example:  gristle_differ file1.dat file2.dat --compare-cols 0, 1 --ignore_cols 19,22,33"
            "\n\n")
    arg_processor = DifferArgProcessor(desc, __doc__)
    args          = vars(arg_processor.args)
    config        = setup_config(args)
    #pp(config)

    # either file may be empty - but at least one must have data in it.
    assert len(config['files']) == 2
    if (os.path.getsize(config['files'][0]) == 0
             and os.path.getsize(config['files'][1]) == 0):
        return 1

    # get csv dialect
    dialect = comm.get_dialect(config['files'], config['delimiter'], config['quoting'],
                               config['quotechar'], config['recdelimiter'],
                               config['hasheader'])

    # prep the files and compare them:
    delta   = delta_runner(config, dialect)

    if config['stats']:
        print
        print 'Counts: '
        print '   File1 dups dropped:   %d' % f0_dups_drop_cnt
        print '   File1 records:        %d' % delta.old_read_cnt
        print '   File2 dups dropped:   %d' % f1_dups_drop_cnt
        print '   File2 records:        %d' % delta.new_read_cnt
        print '   In file1 only:        %d' % delta.out_counts['delete']
        print '   In file2 only:        %d' % delta.out_counts['insert']
        print '   Same:                 %d' % delta.out_counts['same']
        print '   Changed:              %d' % delta.out_counts['chgold']

    return 0



def delta_runner(config, dialect):

    # set up delta processor
    #def fixcols(col_list):
    #    if len(col_list) > 0:
    #        fixcols = [ int(x) for x in col_list ]
    #    else:
    #        fixcols = []
    #    return fixcols

    #adj_key_cols     = fixcols(config['key_cols'])
    #adj_ignore_cols  = fixcols(config['ignore_cols'])
    #adj_compare_cols = fixcols(config['compare_cols'])

    adj_temp_dir     = config['temp_dir'] or dirname(config['files'][1])
    adj_out_dir      = config['out_dir']  or dirname(config['files'][1])

    delta            = gdelta.FileDelta(adj_out_dir, dialect)
    for col in config['key_cols']:
        delta.set_fields('join', col)
    for col in config['ignore_cols']:
        delta.set_fields('ignore', col)
    for col in config['compare_cols']:
        delta.set_fields('compare', col)
    if 'assignments' in config:
        for asgn in config['assignments']:
            delta.set_assignment(**asgn)


    f0_sorted_uniq_fn, f1_dups_drop_cnt = prep_file(delta, config['files'][0],
                                                    dialect, config['key_cols'],
                                                    adj_temp_dir, adj_out_dir,
                                                    config['already_sorted'], config['already_uniq'])
    f1_sorted_uniq_fn, f2_dups_drop_cnt = prep_file(delta, config['files'][1],
                                                    dialect, config['key_cols'],
                                                    adj_temp_dir, adj_out_dir,
                                                    config['already_sorted'], config['already_uniq'])

    # finally, run the comparison
    delta.compare_files(f0_sorted_uniq_fn, f1_sorted_uniq_fn,
                        compare_fields=None,
                        ignore_fields=None,
                        dry_run=config['dry_run'])

    os.remove(f0_sorted_uniq_fn)
    os.remove(f1_sorted_uniq_fn)

    return delta



def prep_file(delta, filename, dialect, key_cols, temp_dir, out_dir, already_sorted, already_uniq):

    if already_sorted:
        sorted_fn       = filename
    else:
        sorter          = gsorter.CSVSorter(dialect, key_cols, temp_dir, out_dir)
        sorted_fn       = sorter.sort_file(filename)

    if already_uniq:
        final_name      = sorted_fn
        dups_removed    = 0
    else:
        deduper         = gdeduper.CSVDeDuper(dialect, key_cols, out_dir)
        final_name, read_cnt, write_cnt = deduper.dedup_file(sorted_fn)
        dups_removed    = read_cnt - write_cnt

    if sorted_fn != filename:
        os.remove(sorted_fn)

    return final_name, dups_removed





class DifferArgProcessor(comm.ArgProcessor):

    def add_custom_args(self):

        self.add_positional_file_args(stdin=False)

        self.parser.add_argument('-k', '--key-cols',
                default=[],
                nargs='*',
                help='Specify the columns that constitute a unique row with a comma-'
                     'delimited list of numbers using a 0-offset.  This is a '
                     'required option.')
        self.parser.add_argument('-c', '--compare-cols',
                nargs='*',
                default=[],
                help=('Columns to compare - described by their position using a zero-offset.'
                      '  Mutually exclusive with ignore-cols'))
        self.parser.add_argument('-i', '--ignore-cols',
                nargs='*',
                default=[],
                help=('Columns to ignore - described by their position using a zero-offset.'
                      ' Mutually exclusive with compare-cols'))
        self.parser.add_argument('--already-sorted',
                default=False,
                action='store_true',
                help='Causes program to bypass sorting step.')
        self.parser.add_argument('--already-uniq',
                default=False,
                action='store_true',
                help='Causes program to bypass deduping step.')
        self.parser.add_argument('--temp-dir',
                help='Used for keeping temporary files.')
        self.parser.add_argument('--out-dir',
                help=('Where the output files will be written.  Defaults to the'
                      ' directory of the second file.'))

        self.add_option_dry_run()
        self.add_option_stats()
        self.add_option_config_name()
        self.add_option_config_fn()
        self.add_option_csv_dialect()
        self.add_option_logging()


def setup_config(args):

    config_schema = {'type': 'object',
                     'properties': {
                       'files':           {"type":     "array"},
                       'temp_dir':        {"required": False},
                       'out_dir':         {"type":     ["null", "string"],
                                           "required": False},
                       'key_cols':        {"type":     "array"},
                       'ignore_cols':     {"type":     "array"},
                       'compare_cols':    {"type":     "array"},
                       'delimiter':       {"type":     ["null", "string"]},
                       'hasheader':       {'type':     ["null", "boolean"]},
                       'recdelimiter':    {"type":     ["null", "string"]},
                       'quoting':         {'type':     ["null", "string"],
                                           "enum":     ["quote_none", "quote_all",
                                                        "quote_minimal", "quote_nonnumeric",
                                                        "0", "1", "2", "3"]},
                       'quotechar':       {"type":     ["null", "string"]},
                       'escapechar':      {"type":     ["null", "string"],
                                           "required": False},
                       'already_sorted':  {"type":     "boolean"},
                       'already_uniq':    {"type":     "boolean"},
                       'stats':           {"type":     "boolean",
                                           "required": False},
                       'dry_run':         {"type":     "boolean"},
                       'log_level':       {"type":     ["null", "string"],
                                           "enum":     ['DEBUG','INFO','WARNING','ERROR','CRITICAL'],
                                           "required": False},
                       'log_to_console':  {"type":     "boolean",
                                           "required": False},
                       'config_fn':       {"required": False},
                       'config_name':     {"required": False},
                       'assignments':     {"type":     "array",
                                           "required": False,
                                           "properties": {
                                                "dest_file":       {"type":    "string"},
                                                "dest_field":      {"type":    "string"},
                                                "src_type":        {"type":    "string"},
                                                "src_val":         {"type":    "string"},
                                                "src_file":        {"type":    "string"},
                                                "src_field":       {"type":    "string"},
                                                "comments":        {"type":    "string"} } },
                       'long_help':       {"type":     "boolean",
                                           "required": False },
                       'help':            {"type":     "boolean",
                                           "required": False },
                       'version':         {'type':     'string',
                                           "required": False },
                      },
                     'additionalProperties': False
                    }

    config        = conf.ConfigManager(config_schema)

    #--- first add all args to namespace ---
    #--- this is because the args have every possible key except for assignments --
    #config.add_iterable(args) - problem - these empty vals end up overriding later

    #--- if the args refer to a config file load it now: ---
    if 'config_fn' in args and args['config_fn']:
        config.add_file(config_fqfn=args['config_fn'])
        print 'adding file!'
    elif 'config_name' in args and args['config_name']:
        config.add_file(app_name=APP_NAME,
                        config_fn='%s.yml' % args['config_name'])
        print 'adding file!'


    print '-------------- after adding file -----------------'
    pp(config.cm_config)

    #--- next add a cleansed version of the args, in which we remove any ---
    #--- with value of None.   We don't want those defaults to override  ---
    #--- within the config file. ---
    def none_remover(a_dict, a_key):
        if isinstance(a_dict[a_key], list) and a_dict[a_key] == []:
            print 'removing %s with a value of None' % a_key
            a_dict.pop(a_key, None)
        elif a_dict[a_key] is None:
            print 'removing %s with a value of None' % a_key
            a_dict.pop(a_key, None)
    args_subset = dict(args)
    #print '-------------- before nonremoving -----------------'
    #pp(args_subset)
    for key in args_subset.keys():
        if key in config.cm_config_file:
            none_remover(args_subset, key)
    #if args_subset['files'] == '-' and config.cm_config
    print '------------- args_subset: --------------'
    pp(args_subset)
    #print 'config key_cols value: %s' % config.key_cols
    #pp(args_subset)
    config.add_iterable(args_subset)
    print '-------------- after adding args -----------------'
    pp(config.cm_config)

    #--- assign defaults
    default = {'dry_run':      False,
               'ignore_cols':  [],
               'compare_cols': [],
               'quotechar':    None,
               'already_sorted': False}
    for key in default:
        if key not in config.cm_config:
            config.add_iterable({key: default[key]})

    #--- fix correctables
    if  config.cm_config.get('delimiter') is not None:
         new_val = comm.dialect_del_fixer(config.cm_config.get('delimiter'))
         config.add_iterable({'delimiter': new_val})

    #    config.dry_run = False
    #--- validate the consolidated config: ---
    #print 'config key_cols value: %s' % config.key_cols
    config.validate()

    confd = config.cm_config # assign internal config dict to local var
    return confd



def validate_config(config):

    if len(config.files) != 2:
        abort("Error: Two file names must be provided as arguments")
    elif not exists(config.files[0]):
        abort("Error: The first file does not exist: %s" % config.files[0])
    elif not exists(config.files[1]):
        abort("Error: The second file does not exist: %s" % config.files[1])

    if config.compare_cols and config.ignore_cols:
        abort("Error: Provide only one of compare_cols or ignore_cols, not both")
    elif config.compare_cols == [] and config.ignore_cols == []:
        abort("Error: One of compare_cols or ignore_cols must be provided")

    for col in config.key_cols:
        if not isnumeric(col):
            abort('Invalid key_cols: must be list of integers: %s' % col)

    for col in config.ignore_cols:
        if not isnumeric(col):
            abort('Invalid ignore_cols: must be list of integers: %s' % col)

    for col in config.compare_cols:
        if not isnumeric(col):
            abort('Invalid compare_cols: must be list of integers: %s' % col)



if __name__ == '__main__':
    sys.exit(main())

