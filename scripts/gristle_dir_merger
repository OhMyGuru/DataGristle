#!/usr/bin/env python
"""
Gristle_dir_merger is used to perform powerful directory merging.

To do:
   - add better comments

This source code is protected by the BSD license.  See the file "LICENSE"
in the source code root directory for the full language or refer to it here:
  http://opensource.org/licenses/BSD-3-Clause

Copyright 2014 Ken Farmer
"""

#--- standard modules ------------------
from __future__ import division
import sys
import argparse
import os
import time
#import re
import math
import shutil
import errno
import glob
import hashlib
import logging
#from pprint import pprint as pp


#--- Ignore SIG_PIPE and don't throw exceptions on it
#--- (http://docs.python.org/library/signal.html)
from signal import signal, SIGPIPE, SIG_DFL
signal(SIGPIPE, SIG_DFL)

#--- gristle modules -------------------
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import gristle.file_type           as file_type
import gristle.common              as comm

__version__ = 'unknown'
try:
    from gristle._version import __version__
except ImportError:
    # We're running in a directory that doesn't have pathing set up quite right
    pass


APP_NAME = 'datagristle'


def main():
    """
    """
    args  = get_args()
    setup_logs(args.log_dir, args.log_level)

    # hypothetically, this could process a list of many directories
    # effectively, it's limited to 2 at present
    for i, adir in enumerate(args.dirlist):
        if i == len(args.dirlist) - 1:
            break  # don't walk through target dest

        process_dir = ProcessDir(adir,
                                 args.dirlist[-1],
                                 args.matchon,
                                 args.onmatch,
                                 args.onpartmatch,
                                 args.dry_run)
        process_dir.walk(adir, args.dirlist[-1])

    return 0



class ProcessDir(object):
    """
    Handles all processing of a single Config Section, each of which has its
    own root directory.
    """

    def __init__(self, source_dir, dest_dir, matchon, full_match, part_match,
                 dry_run=False):

        assert os.path.isdir(source_dir)
        assert os.path.isdir(dest_dir)

        self.matchon       = matchon
        self.source_dir    = source_dir
        self.dest_dir      = dest_dir
        self.dest_files    = {} # key is path, value is list of files
        self.full_match       = full_match
        self.part_match     = part_match
        self.merger        = MergeFiles(dry_run)


    def get_walk_entries(self, a_dir):
        """ Intended to emulate the os.walk() interaction.
            Inputs:
                - a_dir - a directory
            Outputs:
                - dirs  - a list of subdirectories within a_dir
                - files - a list of files within a_dir
        """
        entries = os.listdir(a_dir)
        dirs    = []
        files   = []
        for entry in entries:
            if os.path.isdir(os.path.join(a_dir, entry)):
                dirs.append(entry)
            else:
                files.append(entry)
        return dirs, files


    def walk(self, source_dir, dest_dir):
        """ Inputs:
                - source_dir - fully qualified
                - dest_dir   - fully qualified

            Processing
                - Will call itself
        """
        kill_if_symlink(source_dir)
        kill_if_symlink(dest_dir)

        dirs, files  = self.get_walk_entries(source_dir)

        for dir_name in dirs:

            kill_if_symlink(os.path.join(source_dir, dir_name))
            if os.path.isdir(os.path.join(dest_dir, dir_name)):
                self.walk(os.path.join(source_dir, dir_name),
                          os.path.join(dest_dir, dir_name))
                if is_dir_empty(os.path.join(source_dir, dir_name)):
                    self.merger.keep_dest(source_dir, dir_name, dest_dir, dir_name)
                    log_reason('source_dir empty - will be removed')

            elif os.path.isfile(os.path.join(dest_dir, dir_name)):
                logging.critical('source dir has same name as dest file')
                logging.critical('   source: %s' % (os.path.join(source_dir, dir_name)))
                logging.critical('   dest: %s' % (os.path.join(dest_dir, dir_name)))
                logging.critical('   resolution not supported at this time')
                sys.exit(1)

            else:
                reason = 'source has no matching dest'
                self.merger.keep_source(source_dir, dir_name, dest_dir, dir_name, reason=reason)

        for file_name in files:
            kill_if_symlink(os.path.join(source_dir, file_name))
            self._merge_file(source_dir, file_name, dest_dir)



    def _merge_file(self, sdir, sfile, ddir):
        assert os.path.isdir(sdir)
        assert os.path.isfile(os.path.join(sdir, sfile))
        assert os.path.isdir(ddir)

        if self._is_file_in_destdir(ddir, sfile):
            if self.matchon == 'name_only':
                self.merger.action[self.full_match](sdir, sfile, ddir, sfile)
            elif self.matchon == 'name_and_md5':
                if compare_md5s(sdir, sfile, ddir, sfile) == 'match':
                    self.merger.action[self.full_match](sdir, sfile, ddir, sfile)
                else:
                    self.merger.action[self.part_match](sdir, sfile, ddir, sfile)
        else:
            reason = 'source has no matching dest'
            self.merger._move_source(sdir, sfile, ddir, reason=reason)



    def _is_file_in_destdir(self, dest_dir, file_name):
        if dest_dir not in self.dest_files:
            self.dest_files[dest_dir]   = \
                [os.path.basename(f) for f in glob.glob(os.path.join(dest_dir, '*'))]

        if file_name in self.dest_files[dest_dir]:
            return True
        else:
            return False



class MergeFiles(object):

    def __init__(self, dry_run):
        self.dry_run       = dry_run
        self.action   = {'keep_dest':     self.keep_dest,
                         'keep_source':   self.keep_source,
                         'keep_both':     self.keep_both,
                         'keep_newest':   self.keep_newest,
                         'keep_biggest':  self.keep_biggest }

    def keep_dest(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        self._delete_source(source_dir, source_file, reason=reason)


    def keep_source(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        self._move_source(source_dir, source_file, dest_dir, reason=reason)


    def keep_biggest(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        if os.path.getsize(os.path.join(source_dir, source_file)) \
        > os.path.getsize(os.path.join(dest_dir, dest_file)):
            self._move_source(source_dir, source_file, dest_dir, reason=reason)
        else:
            self._delete_source(source_dir, source_file, reason=reason)


    def keep_newest(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        source_fn_time = os.path.getmtime(os.path.join(source_dir, source_file))
        dest_fn_time   = os.path.getmtime(os.path.join(dest_dir, dest_file))

        if source_fn_time > dest_fn_time:
            self._move_source(source_dir, source_file, dest_dir, reason=reason)
        else:
            self._delete_source(source_dir, source_file, reason=reason)


    def keep_both(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        """ No files will over-write one another - instead the new file will
            get a modified name within the destination directory.
        """
        self._rename_and_move_source(source_dir, source_file, dest_dir, reason=reason)



    def _move_source(self, source_dir, source_file, dest_dir, reason):
        log_action('move_source', os.path.join(source_dir, source_file))
        log_reason(reason)
        assert os.path.exists(os.path.join(source_dir, source_file))
        assert os.path.isdir(dest_dir)
        if not self.dry_run:
            if not os.path.exists(os.path.join(dest_dir, source_file)):
                shutil.move(os.path.join(source_dir, source_file), dest_dir)
            elif (os.path.isfile(os.path.join(source_dir, source_file))
            and os.path.isfile(os.path.join(dest_dir, source_file))):
                shutil.copy2(os.path.join(source_dir, source_file), dest_dir)
                os.remove(os.path.join(source_dir, source_file))


    def _rename_and_move_source(self, source_dir, source_file, dest_dir,
                                dest_file=None, reason=None):

        log_action('rename_and_move_source', os.path.join(source_dir, source_file))
        log_reason(reason)

        if not dest_file:
            dest_file = create_unique_file_name(dest_dir, source_file)

        assert os.path.isfile(os.path.join(source_dir, source_file))
        assert os.path.isdir(dest_dir)
        assert not os.path.exists(os.path.join(dest_dir, dest_file))

        if not self.dry_run:
            shutil.move(os.path.join(source_dir, source_file),
                    os.path.join(dest_dir, dest_file))


    def _delete_source(self, source_dir, source_file=None, reason=None):
        log_action('delete_source', os.path.join(source_dir, source_file or ''))
        log_reason(reason)

        if not self.dry_run:
            adir = os.path.join(source_dir, source_file)
            if os.path.isdir(adir):
                os.rmdir(adir)
            else:
                os.remove(adir)




def compare_md5s(source_dir, source_file, dest_dir, dest_file):

    #---- first run a cheap check: -----
    size1 = os.path.getsize(os.path.join(source_dir, source_file))
    size2 = os.path.getsize(os.path.join(dest_dir, dest_file))
    #if size1 == size2:
    #    return 'match'
    if size1 > size2:
        return 'not-matched'
    elif size1 < size2:
        return 'not-matched'

    #---- next keep comparing sections, hoping to bail out early
    #---- on a difference:
    source_md5 = hashlib.md5()
    dest_md5   = hashlib.md5()
    source_f = open(os.path.join(source_dir, source_file), 'r')
    dest_f   = open(os.path.join(dest_dir,   dest_file), 'r')
    while True:
        source_chunk =  source_f.read(128 * source_md5.block_size)
        dest_chunk   =  dest_f.read(128 * dest_md5.block_size)
        if not source_chunk or not dest_chunk:
            break
        else:
            source_md5.update(source_chunk)
            dest_md5.update(dest_chunk)
            if source_md5.hexdigest() != dest_md5.hexdigest():
                return 'not-matched'

    return 'match'



def is_dir_empty(a_dir):
    if len(os.listdir(a_dir)) == 0:
        return True
    else:
        return False


def create_unique_file_name(dir_name, file_name):
    base_name, extension = os.path.splitext(file_name)

    i = 0
    while os.path.exists(os.path.join(dir_name, file_name)):
        i += 1
        file_name  = '%s.%d%s' % (base_name, i, extension)

    return file_name





def abort(summary, details, rc=1):
    """ Creates formatted error message within a box of = characters
        then exits.
    """

    #---prints top line:
    print('=' * 79)

    #---prints message within = characters, assumes it is kinda short:
    print '=== ',
    print '%-69.69s' % summary,
    print(' ===')
    if logging:
        logging.critical(summary)

    #---prints exception msg, breaks it into multiple lines:
    for i in range(int(math.ceil(len(details)/68))):
        print '=== ',
        print '%-69.69s' % details[i*68:(i*68)+68],
        print ' ==='
    if logging:
        logging.critical(details)

    #---prints bottom line:
    print('=' * 79)

    sys.exit(rc)






def setup_logs(arg_log_dir, log_level='debug', log_to_console=True):
    """ Sets up the cletus logging.  This is just a wrapper around the
        standard logging.
        -  APP_NAME will be used to look up the XDG logging directory
        -  log_name will be used for organizing the logs
        -  arg_log_dir will override default if user provided something
    """
    assert log_level.lower() in ('debug', 'info', 'warning', 'error', 'critical')
    logging.basicConfig(level=log_level.upper(),
                        format='%(message)s')

def log_action(onmatch, file_name):
    logging.info('%s - %s' % (onmatch, file_name))

def log_reason(reason):
    if reason:
        logging.debug('   %s' % reason)




def kill_if_symlink(fqfn):

    if os.path.exists(fqfn):
        if os.path.islink(fqfn):
            logging.critical('Symbolic link not supported: %s' % fqfn)
            sys.exit(1)
    else:
        logging.critical('File missing while checking for symlink: %s' % fqfn)
        sys.exit(1)



def get_args():
    """ gets args and returns them
        Input:
            - command line args & options
        Output:
            - args dictionary
    """
    use = ("%prog is used to consolidate directories"
           " \n"
           "   %prog [file] [misc options]")

    parser = argparse.ArgumentParser(description=use,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('dirlist',
           #dest='dir_list',
           nargs='+',
           help='List of at least two directories. All files'
                ' will be moved into the last (rightmost) entry.')
    parser.add_argument('--match-on',
           dest='matchon',
           choices=['name_only','name_and_md5'],
           required=True,
           help='Matching criteria.  Reference multiple times to include multiple criteria.')
    parser.add_argument('--on-match',
           dest='onmatch',
           choices=['keep_dest', 'keep_source', 'keep_both', 'keep_newest', 'keep_biggest'],
           default='keep_both',
           required=False,
           help='Determines move/copy action for a matched file.')
    parser.add_argument('--on-partial-match',
           dest='onpartmatch',
           choices=['keep_dest', 'keep_source', 'keep_both', 'keep_newest', 'keep_biggest'],
           required=False,
           help='Determines move/copy action for a file with matched name but different content.')


    parser.add_argument('--log-dir',
           dest='log_dir',
           default=None,
           help='Overrides the xdg-default logging directory.  XDG default on linux is $HOME/.cache/datagristle/gristle_process')
    parser.add_argument('--log-level',
           dest='log_level',
           choices=['debug', 'info', 'warning', 'error', 'critical'],
           default='info',
           help='Specifies level of detail in logs.  Default is None - which leaves it to the config file.')

    parser.add_argument('--dry-run',
           default=False,
           action='store_true',
           dest='dry_run',
           help=('Identify files to act upon - but just list them - no movement'))

    parser.add_argument('--long-help',
           default=False,
           action='store_true',
           help='Print more verbose help')
    parser.add_argument('--version',
           action='version',
           version='gristle_dir_merger %s' % __version__)

    args = parser.parse_args()

    if args.long_help:
        print __doc__
        sys.exit(0)

    if args.matchon == 'name_only':
        if args.onpartmatch is not None:
            parser.error("on-partial-match must not be provided when match-on is 'name_only'")
    else:
        if args.onpartmatch is None:
            args.onpartmatch = 'keep_newest'


    return args



if __name__ == '__main__':
    sys.exit(main())

