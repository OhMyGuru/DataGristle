#!/usr/bin/env python
"""
Gristle_dir_merger is used to perform powerful directory merging.

Usage:
  $ gristle_dir_merger [source_dir] [dest_dir] [misc options]

positional arguments:
  source_dir            The source directory - from which files are deleted and
                        moved into the destination directory.
  dest_dir              The destination directory - where files are moved into.

optional arguments:

  --match-on-name-only  Match files on name only.  Overrides default of
                        match-on-name-and-md5.

  --match-on-name-and-md5
                        Match files on name and an MD5 commparison.  This is the
                        default.
  --on-full-match       Action for files matched completely.
         keep_dest    - keeps the desination file and deletes the source file.
                        This is the default - because it is the fastest, and
                        the two files are already deemed to be identical.
         keep_source  - keeps the source and deletes the destination.  This
                        override might be useful if you want to keep the
                        ownership, privs, etc associated with the source file.
                        Or if you're only matching on name.
         keep_both    - keeps both files by copying the source_file over with a
                        slightly modified name - in which a number is inserted
                        prior to the file extension.
         keep_newest  - keeps the newest of the two matching files, as
                        determined by modification time.
         keep_biggest - keeps the largest of the two matching files.

  --on-partial-match    Action for files matched by name, but not by md5.  Only
                        applies to match-on-name-and-md5.
         keep_newest  - keeps the newest of the two matching files, as
                        determined by modification time.  Ths is the default.
         keep_biggest - keeps the largest of the two matching files.
         keep_both    - keeps both files by copying the source_file over with a
                        slightly modified name - in which a number is inserted
                        prior to the file extension.
         keep_dest    - keeps the desination file and deletes the source file.
         keep_source  - keeps the source and deletes the destination.

  --dry-run             Lists files and action, but does not change them.
  -r, --recursive       Walk through directories recursively.  Default is
                        non-recursive

  --log-level {debug,info,warning,error,critical}
                        Level of log detail.  Default is Info.
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  --long-help           Print more verbose help.


Examples
  $ gristle_dir_merger /tmp/foo /data/foo
        - Compares source of /tmp/foo to dest of /data/foo.
        - Files will be consolidated into /data/foo, and deleted from /tmp/foo.
        - Comparison will be: match-on-name-and-md5 (default)
        - Full matches will use: keep_dest (default)
        - Partial matches will use: keep_newest (default)
        - Bottom line: this is what you normally want

  $ gristle_dir_merger /tmp/foo /data/foo --dry-run
        - Same as the first example - except it only prints what it would do
          without actually doing it.
        - Bottom line: this is a good step to take prior to running it for real

  $ gristle_dir_merger /tmp/foo /data/foo -r
        - Same as the first example - except it runs recursively through
          the directories.

  $ gristle_dir_merger /tmp/foo /data/foo --on-partial-match keep-biggest
        - Comparison will be: match-on-name-and-md5 (default)
        - Full matches will use: keep_dest (default)
        - Partial matches will use: keep_biggest (override)
        - Bottom line: this is a good combo if you know that some files
          have been modified on both source & dest, and newest isn't the best.

  $ gristle_dir_merger /tmp/foo /data/foo --match-on-name-only --on-full-match keep-source
        - Comparison will be: match-on-name-only (override)
        - Full matches will use: keep_source (override)
        - Bottom line: this is a good way to go if you have
          files that have changed in both directories, but always want to
          use the source files.


This source code is protected by the BSD license.  See the file "LICENSE"
in the source code root directory for the full language or refer to it here:
  http://opensource.org/licenses/BSD-3-Clause

Copyright 2014 Ken Farmer
"""

#--- standard modules ------------------
from __future__ import division
import sys
import argparse
import os
import time
import math
import shutil
import errno
import glob
import hashlib
import logging

#--- Ignore SIG_PIPE and don't throw exceptions on it
#--- (http://docs.python.org/library/signal.html)
from signal import signal, SIGPIPE, SIG_DFL
signal(SIGPIPE, SIG_DFL)

#--- gristle modules -------------------
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import gristle.file_type           as file_type
import gristle.common              as comm

__version__ = 'unknown'
try:
    from gristle._version import __version__
except ImportError:
    # We're running in a directory that doesn't have pathing set up quite right
    pass



def main():
    """
    """
    args  = get_args()
    setup_logs(args.log_level)

    process_dir = ProcessDir(args.source_dir,
                             args.dest_dir,
                             args.matchon,
                             args.on_f_match,
                             args.on_p_match,
                             args.recursive,
                             args.dry_run)

    process_dir.walk(args.source_dir, args.dest_dir)

    process_dir.generate_dest_counts()
    if args.stats:
        logging.info('---------- Counts -----------')
        logging.info('Total Source Objects:       %d' % (process_dir.sdir_cnt + process_dir.sfile_cnt))
        logging.info('   Directory Read Cnt:      %d' % process_dir.sdir_cnt)
        logging.info('   File Read Cnt:           %d' % process_dir.sfile_cnt)
        logging.info('      DotFile Read Cnt:     %d' % process_dir.sdotfile_cnt)
        logging.info('Total Dest Objects:         %d' % (process_dir.ddir_cnt + process_dir.dfile_cnt))
        logging.info('   Directory Read Cnt:      %d' % process_dir.ddir_cnt)
        logging.info('   File Read Cnt:           %d' % process_dir.dfile_cnt)
        logging.info('')
        logging.info('Full Match Cnt:             %d' % process_dir.full_match_cnt)
        logging.info('Partial Match Cnt:          %d' % process_dir.partial_match_cnt)
        logging.info('No Match Cnt:               %d' % process_dir.no_match_cnt)
        logging.info('')
        logging.info('Delete Source Cnt:          %d' % process_dir.merger.delete_source_cnt)
        logging.info('Move Source Cnt:            %d' % process_dir.merger.move_source_cnt)
        logging.info('Rename And Move Source Cnt: %d' % process_dir.merger.rename_and_move_source_cnt)

    return 0



class ProcessDir(object):
    """ Handles walking through the directories then running the merge process
        against files within them.
    """

    def __init__(self, source_dir, dest_dir, matchon, full_match, part_match,
                 recursive, dry_run=False):

        assert os.path.isdir(source_dir)
        assert os.path.isdir(dest_dir)

        self.recursive     = recursive
        self.matchon       = matchon
        self.source_dir    = source_dir
        self.dest_dir      = dest_dir
        self.dest_dirs     = {} # key is dirpath, value is count of files within
        self.dest_files    = {} # key is dirpath, value is list of files
        self.full_match    = full_match
        self.part_match    = part_match
        self.merger        = MergeFiles(dry_run)
        self.full_match_cnt    = 0
        self.partial_match_cnt = 0
        self.no_match_cnt      = 0
        self.sdir_cnt          = 0
        self.sfile_cnt         = 0
        self.sdotfile_cnt      = 0
        self.ddir_cnt          = 0
        self.dfile_cnt         = 0


    def get_walk_entries(self, a_dir):
        """ Intended to emulate the os.walk() interaction.
            Inputs:
                - a_dir - a directory
            Outputs:
                - dirs  - a list of subdirectories within a_dir
                - files - a list of files within a_dir
        """
        entries = os.listdir(a_dir)
        dirs    = []
        files   = []
        for entry in entries:
            if os.path.isdir(os.path.join(a_dir, entry)):
                dirs.append(entry)
            else:
                files.append(entry)
        return dirs, files


    def walk(self, source_dir, dest_dir):
        """ Inputs:
                - source_dir - fully qualified
                - dest_dir   - fully qualified
            Processing
                - Will call itself
                - Will terminate the program if it encounters a symbolic link
        """
        kill_if_symlink(source_dir, 'source')
        kill_if_symlink(dest_dir, 'dest')

        dirs, files  = self.get_walk_entries(source_dir)

        for dir_name in dirs:

            self.sdir_cnt += 1
            self._is_file_in_destdir(dest_dir, None) # only call for stats
            kill_if_symlink(os.path.join(source_dir, dir_name), 'source')
            kill_if_symlink(os.path.join(dest_dir, dir_name), 'dest')
            if os.path.isdir(os.path.join(source_dir, dir_name)):
                if self.recursive:
                    self.walk(os.path.join(source_dir, dir_name),
                              os.path.join(dest_dir, dir_name))
                if is_dir_empty(os.path.join(source_dir, dir_name)):
                    self.merger.keep_dest(source_dir, dir_name, dest_dir, dir_name)
                    log_reason('source_dir empty - will be removed')

            elif os.path.isfile(os.path.join(dest_dir, dir_name)):
                logging.critical('source dir has same name as dest file')
                logging.critical('   source: %s' % (os.path.join(source_dir, dir_name)))
                logging.critical('   dest: %s' % (os.path.join(dest_dir, dir_name)))
                logging.critical('   resolution not supported at this time')
                sys.exit(1)

            else:
                self.no_match_cnt += 1
                reason = 'source_dir has no matching dest'
                self.merger.keep_source(source_dir, dir_name, dest_dir, dir_name, reason=reason)

        for file_name in files:
            self.sfile_cnt += 1
            if file_name.startswith('.'):
               self.sdotfile_cnt += 1
            self._merge_file(source_dir, file_name, dest_dir)



    def _merge_file(self, sdir, sfile, ddir):
        """ Attempts to match a source file against a corresponding one in the
            dest dir by name_only or name_and_md5.  Then it performs the action
            specified for the level of match that occurred.
            Inputs:
               - sdir  - the source_dir
               - sfile - the source_file
               - ddir  - the dest-dir - may not exist
        """
        assert os.path.isdir(sdir)
        assert os.path.isfile(os.path.join(sdir, sfile))

        #ddir may be missing
        #assert os.path.isdir(ddir), '_merge_file.ddir missing: %s' % ddir

        if self._is_file_in_destdir(ddir, sfile):
            if self.matchon == 'name_only':
                self.merger.action[self.full_match](sdir, sfile, ddir, sfile)
                self.full_match_cnt += 1
            elif self.matchon == 'name_and_md5':
                if compare_md5s(sdir, sfile, ddir, sfile) == 'matched':
                    self.full_match_cnt += 1
                    self.merger.action[self.full_match](sdir, sfile, ddir, sfile)
                else:
                    self.partial_match_cnt += 1
                    self.merger.action[self.part_match](sdir, sfile, ddir, sfile)
            else:
                logging.critical('Logic Error, bad value: %s' % self.matchon)
                sys.exit(2)
        else:
            self.no_match_cnt += 1
            reason = 'source_file has no matching dest'
            self.merger.keep_source(sdir, sfile, ddir, sfile, reason=reason)



    def _is_file_in_destdir(self, dest_dir, file_name):
        """ Determines if source_file is also in the corresponding dest_dir.
            Inputs:
                - dest_dir
                - file_name
            Outputs:
                - Boolean
        """
        if dest_dir not in self.dest_dirs:
            dest_file_list = glob.glob(os.path.join(dest_dir, '*'))
            dest_file_list.extend(glob.glob(os.path.join(dest_dir, '.*')))
            self.dest_dirs[dest_dir]  = len(dest_file_list)
            self.dest_files[dest_dir] = [os.path.basename(f) for f in dest_file_list]

        if file_name:
            if file_name in self.dest_files[dest_dir]:
                return True
            else:
                return False


    def generate_dest_counts(self):
        ddir_cnt  = 0
        dfile_cnt = 0
        for key, value in self.dest_dirs.iteritems():
            if value > 0:
                ddir_cnt  += 1
                dfile_cnt += value
        self.ddir_cnt  = ddir_cnt
        self.dfile_cnt = dfile_cnt - ddir_cnt



class MergeFiles(object):
    """ A collection of methods used to merge directories and files.
        Inputs:
           - dry_run
    """

    def __init__(self, dry_run):
        self.dry_run       = dry_run
        self.action   = {'keep_dest':     self.keep_dest,
                         'keep_source':   self.keep_source,
                         'keep_both':     self.keep_both,
                         'keep_newest':   self.keep_newest,
                         'keep_biggest':  self.keep_biggest }
        self.move_source_cnt             = 0
        self.rename_and_move_source_cnt  = 0
        self.delete_source_cnt           = 0

    def keep_dest(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        self._delete_source(source_dir, source_file, reason=reason)


    def keep_source(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        self._move_source(source_dir, source_file, dest_dir, reason=reason)


    def keep_biggest(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        if os.path.getsize(os.path.join(source_dir, source_file)) \
        > os.path.getsize(os.path.join(dest_dir, dest_file)):
            self._move_source(source_dir, source_file, dest_dir, reason=reason)
        else:
            self._delete_source(source_dir, source_file, reason=reason)


    def keep_newest(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        source_fn_time = os.path.getmtime(os.path.join(source_dir, source_file))
        dest_fn_time   = os.path.getmtime(os.path.join(dest_dir, dest_file))

        if source_fn_time > dest_fn_time:
            self._move_source(source_dir, source_file, dest_dir, reason=reason)
        else:
            self._delete_source(source_dir, source_file, reason=reason)


    def keep_both(self, source_dir, source_file, dest_dir, dest_file, reason=''):
        """ No files will over-write one another - instead the new file will
            get a modified name within the destination directory.
        """
        self._rename_and_move_source(source_dir, source_file, dest_dir, reason=reason)


    def _move_source(self, source_dir, source_file, dest_dir, reason):

        dest_file = source_file

        log_action('move_source', os.path.join(source_dir, source_file))
        log_reason(reason)
        kill_if_symlink(os.path.join(source_dir, source_file), 'source')
        kill_if_symlink(os.path.join(dest_dir, dest_file), 'dest')
        self.move_source_cnt += 1

        assert os.path.exists(os.path.join(source_dir, source_file))
        if source_file:
            assert os.path.isfile(os.path.join(source_dir, source_file))
        if not os.path.isdir(dest_dir):
            logging.info('dest_dir does not exist, will be created: %s' % dest_dir)
        if os.path.isfile(dest_dir):
            logging.critical('dest_dir exists, but is a file: %s' % dest_dir)
            sys.exit(2)

        if not self.dry_run:

            create_dest_dir_if_needed(dest_dir)

            if dest_file:
                shutil.copy2(os.path.join(source_dir, source_file), dest_dir)
                os.remove(os.path.join(source_dir, source_file))
            else:
                # may break since we're building dest directories above
                shutil.move(source_dir, dest_dir)



    def _rename_and_move_source(self, source_dir, source_file, dest_dir,
                                dest_file=None, reason=None):

        log_action('rename_and_move_source', os.path.join(source_dir, source_file))
        log_reason(reason)
        kill_if_symlink(os.path.join(source_dir, source_file), 'source')
        self.rename_and_move_source_cnt += 1

        if not dest_file:
            dest_file = create_unique_file_name(dest_dir, source_file)

        assert os.path.isfile(os.path.join(source_dir, source_file))
        assert os.path.isdir(dest_dir)
        assert not os.path.exists(os.path.join(dest_dir, dest_file))

        if not self.dry_run:
            shutil.move(os.path.join(source_dir, source_file),
                    os.path.join(dest_dir, dest_file))


    def _delete_source(self, source_dir, source_file=None, reason=None):
        log_action('delete_source', os.path.join(source_dir, source_file or ''))
        log_reason(reason)
        kill_if_symlink(os.path.join(source_dir, source_file), 'source')
        self.delete_source_cnt += 1

        if not self.dry_run:
            adir = os.path.join(source_dir, source_file)
            if os.path.isdir(adir):
                os.rmdir(adir)
            else:
                os.remove(adir)



def create_dest_dir_if_needed(dest_dir):
    if not os.path.exists(dest_dir):
        os.mkdir(dest_dir)
        logging.info('Created dir: %s' % dest_dir)


def compare_md5s(source_dir, source_file, dest_dir, dest_file):
    """ Compares two files to determine if their content is identical
        through the use of MD5 hashes.   Two optimizations exist:
           - it first checks to see if the file sizes are identical
           - it only compares 128*md5 block size at a time
        Inputs:
           - source_dir
           - source_file
           - dest_dir
           - dest_file
        Outputs:
           - result of either 'matched' or 'not-matched'
    """
    #---- first run a cheap check: -----
    size1 = os.path.getsize(os.path.join(source_dir, source_file))
    size2 = os.path.getsize(os.path.join(dest_dir, dest_file))
    #if size1 == size2:
    #    return 'match'
    if size1 > size2:
        return 'not-matched'
    elif size1 < size2:
        return 'not-matched'

    #---- next keep comparing sections, hoping to bail out early
    #---- on a difference:
    source_md5 = hashlib.md5()
    dest_md5   = hashlib.md5()
    source_f = open(os.path.join(source_dir, source_file), 'r')
    dest_f   = open(os.path.join(dest_dir,   dest_file), 'r')
    while True:
        source_chunk =  source_f.read(128 * source_md5.block_size)
        dest_chunk   =  dest_f.read(128 * dest_md5.block_size)
        if not source_chunk or not dest_chunk:
            break
        else:
            source_md5.update(source_chunk)
            dest_md5.update(dest_chunk)
            if source_md5.hexdigest() != dest_md5.hexdigest():
                return 'not-matched'

    return 'matched'



def is_dir_empty(a_dir):
    """ Determines if a directory has files or subdirectories within it.
        Inputs:
            - a_dir - the directory name to check.   This should be fully
              qualified.
        Outputs:
            - boolean
    """
    if len(os.listdir(a_dir)) == 0:
        return True
    else:
        return False


def create_unique_file_name(dir_name, file_name):
    """ Creates a unique file name for the keep_both aciton.  This allows
        the source file to be copied to the dest directory with a minor
        modification in order to not step on the matching dest_file.

        If no file already exists with the current name then it won't be
        changed.  If it has to be changed, this process will try inserting
        a number between the file's base_name and its extension.

        Inputs:
           - dir_name  - should be the dest_dir
           - file_name - can be either the source_file or dest_file, should
                         be unqualified.
        Outputs:
           - file_name - this is the unqualified, but modified file_name.
    """
    base_name, extension = os.path.splitext(file_name)

    i = 0
    while os.path.exists(os.path.join(dir_name, file_name)):
        i += 1
        file_name  = '%s.%d%s' % (base_name, i, extension)

    return file_name





def abort(summary, details, rc=1):
    """ Creates formatted error message within a box of = characters
        then exits.
    """

    #---prints top line:
    print('=' * 79)

    #---prints message within = characters, assumes it is kinda short:
    print '=== ',
    print '%-69.69s' % summary,
    print(' ===')
    if logging:
        logging.critical(summary)

    #---prints exception msg, breaks it into multiple lines:
    for i in range(int(math.ceil(len(details)/68))):
        print '=== ',
        print '%-69.69s' % details[i*68:(i*68)+68],
        print ' ==='
    if logging:
        logging.critical(details)

    #---prints bottom line:
    print('=' * 79)

    sys.exit(rc)






def setup_logs(log_level='debug', log_to_console=True):
    """
    """
    assert log_level.lower() in ('debug', 'info', 'warning', 'error', 'critical')
    logging.basicConfig(level=log_level.upper(),
                        format='%(message)s')

def log_action(on_f_match, file_name):
    logging.info('%s - %s' % (on_f_match, file_name))

def log_reason(reason):
    if reason:
        logging.debug('   %s' % reason)




def kill_if_symlink(fqfn, dir_type):
    """ Tests a fully-qualified file name to see if it's a symlink.
        Inputs:
            - fqfn - "fully qualified file name" - may be either a file or a
                     directory
            - dir_type - must be either 'source' or 'dest'
        Process:
            - if the fqfn is a symlink, it will write an error msg to the log
              and immediately exit the program.
            - if the file doesn't exist, and it's a source dir_type, then it
              will also error & exit the program.  This is because navigation
              occurs through source_dir - so files should never turn up missing.
              But they may have no corresponding directory on the dest side.
    """
    assert dir_type in ['source','dest']
    if os.path.exists(fqfn):
        if os.path.islink(fqfn):
            logging.critical('Symbolic link not supported: %s' % fqfn)
            sys.exit(1)
    else:
        if dir_type == 'source':
            logging.critical('File missing while checking for symlink: %s' % fqfn)
            sys.exit(1)



def get_args():
    """ gets args and returns them
        Input:
            - command line args & options
        Output:
            - args dictionary
    """
    use = ("gristle_dir_merger is used to merge directories"
           " \n"
           "   gristle_dir_merger source_dir dest_dir [misc options]")

    parser = argparse.ArgumentParser(description=use,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('source_dir',
           help='Source directory.  Files from here will be deleted or moved into the dest_dir.')
    parser.add_argument('dest_dir',
           help='Destination directory.  Files from the source_dir will be copied into here.')
    parser.add_argument('--match-on-name-only',
           dest='matchon',
           action='store_const',
           const='name_only',
           help='Match files on name only.  Overrides default of match-on-name-and-md5.')
    parser.add_argument('--match-on-name-and-md5',
           dest='matchon',
           action='store_const',
           const='name_and_md5',
           help='Match files on name and an MD5 commparison.  This is the default.')
    parser.add_argument('--on-full-match',
           dest='on_f_match',
           choices=['keep_dest', 'keep_source', 'keep_both', 'keep_newest', 'keep_biggest'],
           default='keep_dest',
           required=False,
           help='Action for files matched completely.  Default is keep_dest.')
    # default added below so it won't get added with match-on-name-only:
    parser.add_argument('--on-partial-match',
           dest='on_p_match',
           choices=['keep_dest', 'keep_source', 'keep_both', 'keep_newest', 'keep_biggest'],
           required=False,
           help='Action for files matched by name but with different content.  Default is keep_newest.')


    parser.add_argument('--dry-run',
           default=False,
           action='store_true',
           dest='dry_run',
           help='Lists files and action, but does not change them.')

    parser.add_argument('-r', '--recursive',
           default=False,
           action='store_true',
           help='Walk through directories recursively.  Default is non-recursive')

    parser.add_argument('-s', '--stats',
           default=False,
           action='store_true',
           help='Print statistics at end of job.  Default is False.')

    parser.add_argument('--log-level',
           dest='log_level',
           choices=['debug', 'info', 'warning', 'error', 'critical'],
           default='info',
           help='Level of log detail.  Default is Info.')

    parser.add_argument('--long-help',
           default=False,
           action='store_true',
           help='Print more verbose help.')

    parser.add_argument('--version',
           action='version',
           version='gristle_dir_merger %s' % __version__)

    if '--long-help' in sys.argv:
        print __doc__
        sys.exit(0)

    args = parser.parse_args()

    if args.matchon is None:
        args.matchon = 'name_and_md5'

    if args.matchon == 'name_only':
        if args.on_p_match is not None:
            parser.error("on-partial-match must not be provided when match-on is 'name_only'")
    else:
        if args.on_p_match is None:
            args.on_p_match = 'keep_newest'


    return args



if __name__ == '__main__':
    sys.exit(main())

